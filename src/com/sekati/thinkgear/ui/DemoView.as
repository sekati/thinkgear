/** * com.sekati.thinkgear.ui.demo.DemoView * @version 1.0.0 * @author jason m horwitz | sekati.com * Copyright (C) 2010  jason m horwitz, Sekat LLC. All Rights Reserved. * Released under the MIT License: http://www.opensource.org/licenses/mit-license.php */package com.sekati.thinkgear.ui {	import caurina.transitions.Tweener;	import sekati.collections.TypedArray;	import sekati.converters.BoolConverter;	import sekati.core.App;	import sekati.display.Canvas;	import sekati.display.CoreSprite;	import sekati.display.StageDisplay;	import sekati.log.Logger;	import sekati.math.MathBase;	import sekati.utils.ColorUtil;	import sekati.views.AbstractView;	import com.sekati.thinkgear.core.ThinkGearConnector;	import com.sekati.thinkgear.data.EEGPowers;	import com.sekati.thinkgear.events.EEGPowersEvent;	import com.sekati.thinkgear.events.ESenseDataEvent;	import flash.events.KeyboardEvent;	import flash.events.TextEvent;	import flash.text.AntiAliasType;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.ui.Keyboard;	/**	 * DemoView provides a visual demostrations of the ThinkGear readings using ForceSprites.	 */	final public class DemoView extends AbstractView {		public static const AMOUNT : int = 50;		public static const ACCELERATION : Number = 10;		public static const FRICTION : Number = 0.6;		public static const GRAVITY : int = 20;		private static const THRESHOLD_DEFAULT : int = App.db.config.custom.thinkgear.esense.threshold.baseline;		private static const THRESHOLD_INCREMENT : int = App.db.config.custom.thinkgear.esense.threshold.increment;		private static const ATTENTION_COLOR : uint = App.db.config.custom.thinkgear.esense.attention.color;		private static const MEDITATION_COLOR : uint = App.db.config.custom.thinkgear.esense.meditation.color;			private static const CAPTION : String = App.db.config.custom.thinkgear.header.caption;		private static const CAPTION_ALPHA : Number = App.db.config.custom.thinkgear.header.copy.alpha;				private static const CAPTION_COLOR : uint = App.db.config.custom.thinkgear.header.copy.color;		private static const CAPTION_SUB_COLOR : uint = App.db.config.custom.thinkgear.header.copy.sub_color;		private static const CAPTION_TITLE_COLOR : uint = App.db.config.custom.thinkgear.header.copy.title_color;					private static const ATTENTION_LABEL : String = App.db.config.custom.thinkgear.esense.attention.name.toUpperCase( );			private static const MEDITATION_LABEL : String = App.db.config.custom.thinkgear.esense.meditation.name.toUpperCase( );			private static const FLOAT_PRECISION : uint = App.db.config.custom.thinkgear.esense.float_precision;		private static const METER : XMLList = App.db.config.custom.thinkgear.esense.meter;		// wave labels		private static const DELTA_LABEL : String = App.db.config.custom.thinkgear.wave.delta.name.toUpperCase( );			private static const THETA_LABEL : String = App.db.config.custom.thinkgear.wave.theta.name.toUpperCase( );					private static const ALPHA_LOW_LABEL : String = App.db.config.custom.thinkgear.wave.alpha_low.name.toUpperCase( );			private static const ALPHA_HIGH_LABEL : String = App.db.config.custom.thinkgear.wave.alpha_high.name.toUpperCase( );					private static const BETA_LOW_LABEL : String = App.db.config.custom.thinkgear.wave.beta_low.name.toUpperCase( );			private static const BETA_HIGH_LABEL : String = App.db.config.custom.thinkgear.wave.beta_high.name.toUpperCase( );					private static const GAMMA_LOW_LABEL : String = App.db.config.custom.thinkgear.wave.gamma_low.name.toUpperCase( );			private static const GAMMA_HIGH_LABEL : String = App.db.config.custom.thinkgear.wave.gamma_high.name.toUpperCase( );		// wave colors		private static const DELTA_COLOR : uint = App.db.config.custom.thinkgear.wave.delta.color;			private static const THETA_COLOR : uint = App.db.config.custom.thinkgear.wave.theta.color;					private static const ALPHA_LOW_COLOR : uint = App.db.config.custom.thinkgear.wave.alpha_low.color;			private static const ALPHA_HIGH_COLOR : uint = App.db.config.custom.thinkgear.wave.alpha_high.color;					private static const BETA_LOW_COLOR : uint = App.db.config.custom.thinkgear.wave.beta_low.color;			private static const BETA_HIGH_COLOR : uint = App.db.config.custom.thinkgear.wave.beta_high.color;					private static const GAMMA_LOW_COLOR : uint = App.db.config.custom.thinkgear.wave.gamma_low.color;			private static const GAMMA_HIGH_COLOR : uint = App.db.config.custom.thinkgear.wave.gamma_high.color;													// textlink events		private static const TEXTLINK_FULLSCREEN_EVENT : String = 'fullscreenLink';		private static const TEXTLINK_THRESHOLD_EVENT : String = 'thresholdLink';				// meter low-hi tween		private static const METER_TWEEN : Object = { time:1, transition:"easeOutExpo" };		// our actual stored eSense & powers values		private var attention : int;		private var meditation : int;		private var powerData : EEGPowers;		// our minimum threshold to display visual activity from an eSense 			private var esenseThreshold : int = THRESHOLD_DEFAULT;		// track thresh lo's and hi's		private var highMeterFlag : Boolean;		private var lowMeterFlag : Boolean;				// meter level names for header and weighing purposes.		private	var attentionMeterLevelName : String;		private	var meditationMeterLevelName : String;								// ui		private var ballContainer : CoreSprite;		private var ballCollection : TypedArray;		private var signalMeter : SignalMeter;		private var tf : TextField;		private var fmt : TextFormat;		/**		 * DemoView Constructor		 */		public function DemoView() {			super( );		}		/**		 * @inheritDoc		 */		override protected function configUI() : void {				//cacheAsBitmap = true;			initBallCollection( );			initHeader( );			initKeyBindings( );			initSignalMeter( );			initVisualizer( );				}		/**		 * Initialize the ball collection.		 */		private function initBallCollection() : void {			ballContainer = new CoreSprite( );			addChild( ballContainer );			ballCollection = new TypedArray( DemoBall );						for (var i : int = 0; i < AMOUNT ; i++) {				var ball : DemoBall = new DemoBall( 0, 0, NaN, FRICTION ); // the mass is defined by the size in the ball.				ballCollection.push( ball );			}			ballContainer.addChildren.apply( this, ballCollection );				}		/**		 * Initialize the TextField UI.		 */		private function initHeader() : void {			var copy : XMLList = App.db.config.custom.thinkgear.header.copy;			tf = new TextField( );			fmt = new TextFormat( );			fmt.font = copy.font;			fmt.size = copy.size;			fmt.bold = BoolConverter.toBoolean( copy.bold );			fmt.leading = copy.leading;			tf.y = tf.x = copy.xy;			tf.multiline = true;			tf.autoSize = TextFieldAutoSize.LEFT;			tf.textColor = CAPTION_COLOR;			tf.alpha = CAPTION_ALPHA;			tf.selectable = false;			tf.antiAliasType = AntiAliasType.ADVANCED;			tf.setTextFormat( fmt );			addChild( tf );			mouseChildren = true;			tf.addEventListener( TextEvent.LINK, captionLinkClickHandler, false, 0, true );		}		/**		 * Initialize Key Listeners		 */		private function initKeyBindings() : void {			Canvas.stage.addEventListener( KeyboardEvent.KEY_DOWN, keyDownHandler, false, 0, true );			Canvas.stage.addEventListener( KeyboardEvent.KEY_UP, keyUpHandler, false, 0, true );		}				/**		 * Initialize the SignalMeter UI		 */		private function initSignalMeter() : void {			signalMeter = new SignalMeter( );			addChild( signalMeter );					}		/**		 * This function begins listening for attention and meditation values		 * and updates the UI at each interval tick.		 */		private function initVisualizer() : void {			ThinkGearConnector.$.reader.addEventListener( ESenseDataEvent.ESENSE_DATA, eSenseDataHandler, false, 0, true );			ThinkGearConnector.$.reader.addEventListener( EEGPowersEvent.EEG_POWERS_DATA, eegPowersUpdateHandler, false, 0, true );		}		/**		 * Here we handle the ePowerData flowing in and display it in the header & compare to find the largest change		 */		private function eegPowersUpdateHandler(e : EEGPowersEvent) : void {			//Logger.$.notice( this, "POWERS VISUALIZE => " + e.eegPowers.toString( ) );						// save the old and store the new data ...			//var prevPower : EEGPowers = powerData;			powerData = e.eegPowers;			updateHeader( );						/*			if(prevPower) {				// compare all the data - really lousy way to do this ... but we're just tryin stuff out here.				var d : Number = powerData.delta - prevPower.delta;				var t : Number = powerData.theta - prevPower.theta;				var al : Number = powerData.alpha.low - prevPower.alpha.low;				var ah : Number = powerData.alpha.high - prevPower.alpha.high;				var bl : Number = powerData.beta.low - prevPower.beta.low;				var bh : Number = powerData.beta.high - prevPower.beta.high;				var gl : Number = powerData.gamma.low - prevPower.gamma.low;				var gh : Number = powerData.gamma.high - prevPower.gamma.high;				var arr : Array = [ d, t, al, ah, bl, bh, gl, gh ];				arr.sort( Array.NUMERIC );				var color : uint;				var type : String;				switch(arr[0]) {					case d:						type = DELTA_LABEL;						color = DELTA_COLOR;						break;					case t:						type = THETA_LABEL;						color = THETA_COLOR;						break;					case al:						type = ALPHA_LOW_LABEL;						color = ALPHA_LOW_COLOR;						break;					case ah:						type = ALPHA_HIGH_LABEL;						color = ALPHA_HIGH_COLOR;										break;					case bl:						type = BETA_LOW_LABEL;							color = BETA_LOW_COLOR;						break;					case bh:						type = BETA_HIGH_LABEL;						color = BETA_HIGH_COLOR;						break;					case gl:						type = GAMMA_LOW_LABEL;						color = GAMMA_LOW_COLOR;						break;																																			case gh:						type = GAMMA_HIGH_LABEL;						color = GAMMA_HIGH_COLOR;						break;									}				//Logger.$.error( this, "POWERS SORT WINNER: " + type + " @ " + arr[0] + " => " + color );				for (var i : int = 0; i < ballCollection.length ; i++) {					var ball : DemoBall = ballCollection[i] as DemoBall;					Tweener.addTween( ball, { _color:color, time:2, delay:(i * 0.01), transition:"easeOutExpo" } );				}				}			*/		}		/**		 * Here we handle the eSenseData flowing in & visualize based on attention and the color based on meditation!		 */		private function eSenseDataHandler(e : ESenseDataEvent) : void {			//--------------------------------------------------------------				// store the eSense data			attention = e.eSenseData.attention;			meditation = e.eSenseData.meditation;			// save our meter level names for header and comparison			attentionMeterLevelName = resolveMeterLevelName( attention );			meditationMeterLevelName = resolveMeterLevelName( meditation ); 						// update our display			updateHeader( );						//Logger.$.notice( this, "SENSE VISUALIZE => attention: " + attention + ", meditation: " + meditation );						//--------------------------------------------------------------						// The goal here is to put some kind of scoring system in place			// so the user can train between good attention & meditation values			// and level control.						//--------------------------------------------------------------						// start with no force & full gravity.			var ax : Number = 0;			var ay : Number = 0;			var gravity : Number = GRAVITY;						// XXX - we counter the acceleration x's to share the push/pull between the esenses.			//--------------------------------------------------------------					// ABOVE THRESHOLD						// Act only if either esense has crossed the set threshold:			if(attention >= esenseThreshold || meditation >= esenseThreshold) {								//gravity = (attention >= esenseThreshold && meditation >= esenseThreshold) ? -5 : 0; // remove gravity, anti-gravity if both are tuned!				gravity = 0; // remove gravity!				// add "levitating" acceleration from both attention and meditation!				if(attention >= esenseThreshold) {					ay -= (ACCELERATION * 100 / attention); // float (x-treme)					ax -= (attention >= meditation) ? (ACCELERATION * 100 / attention) : 0; // drift (x-treme) left when stronger than meditation					//ay -= (ACCELERATION / attention); // float					//ax -= (attention >= meditation) ? (ACCELERATION / attention) : 0; // drift left when stronger than meditation				}				if(meditation >= esenseThreshold) {					ay -= (ACCELERATION * 100 / meditation); // float									ax += (attention <= meditation) ? (ACCELERATION * 100 / meditation) : 0; // drift (x-treme) right when stronger than attention					//ay -= (ACCELERATION / meditation); // float					//ax += (attention <= meditation) ? (ACCELERATION / meditation) : 0; // drift right when stronger than attention										}			}						// check if we've hit either high or low levels and make display changes for these extreme states ...			visualizeHighMeterLevels( );			visualizeLowMeterLevels( );						// --- render loop ---			//Logger.$.notice( this, "gravity: " + gravity + ", ay: " + ay + ", ax: " + ax );			applyForces( ax, ay, gravity );		}		/**		 * Evaluate high meter flag & visualize/unvisualize accordingly.		 */		private function visualizeHighMeterLevels() : void {				var isHighLevel : Boolean = (attentionMeterLevelName == METER.highest.name || meditationMeterLevelName == METER.highest.name);			if(isHighLevel && !highMeterFlag) {				Logger.$.warn( this, "Fire High Level VIZ => isHighLevel = " + isHighLevel + " highMeter = " + highMeterFlag );							highMeterFlag = true;				// visualize				applyAlpha( DemoBall.ALPHA_HIGH ); // make all balls solid!			}			if(!isHighLevel && highMeterFlag) {				Logger.$.warn( this, "Fire High Level UNVIZ <= isHighLevel = " + isHighLevel + " highMeter = " + highMeterFlag );							highMeterFlag = false;				// unvisualize				applyAlpha( DemoBall.ALPHA ); // reset back to normal alpha			}		}		/**		 * Evaluate low meter flag & visualize/unvisualize accordingly.		 */		private function visualizeLowMeterLevels() : void {				var isLowLevel : Boolean = (attentionMeterLevelName == METER.none.name && meditationMeterLevelName == METER.none.name);			if(isLowLevel && !lowMeterFlag) {				Logger.$.warn( this, "Fire Low Level VIZ => isLowLevel = " + isLowLevel + " lowMeterFlag = " + lowMeterFlag );							lowMeterFlag = true;				// visualize				Tweener.addTween( ballContainer, { base:METER_TWEEN, _Blur_blurX:15, _Blur_blurY:15 } );			} 			if(!isLowLevel && lowMeterFlag) {				Logger.$.warn( this, "Fire LOW Level UNVIZ <= isLowLevel = " + isLowLevel + " lowMeterFlag = " + lowMeterFlag );							lowMeterFlag = false;				// unvisualize				Tweener.addTween( ballContainer, { base:METER_TWEEN, _Blur_blurX:0, _Blur_blurY:0 } );			}		}		/**		 * Handle Up Key		 */		private function keyUpHandler(e : KeyboardEvent) : void {			resetForces( );		}		/**		 * Handle Left, Right & Down Key		 */		private function keyDownHandler(e : KeyboardEvent) : void {			// start with a default no-force state ...			var ax : Number = 0;			var ay : Number = 0;			var gravity : Number = GRAVITY;						switch (e.keyCode) {			//User pressed the left arrow --> x acceleration negative				case Keyboard.LEFT :					ax = -ACCELERATION;					break; 			//User pressed the right arrow --> x acceleration positive				case Keyboard.RIGHT :					ax = ACCELERATION;					break;			//User pressed the up arrow --> y acceleration negative. Apply no gravity when up key down.				case Keyboard.UP :					ay = -ACCELERATION;					gravity = 0;					break;			//User pressed the down arrow --> y acceleration positivve				case Keyboard.DOWN :					ay = ACCELERATION;					break;								// User pressed the space bar --> increment the esense threshold				case Keyboard.SPACE : 					incrementThreshold( );					break;						default:					return;					break;			}						// pass the key'd accelerations to the force sprite ..			applyForces( ax, ay, gravity );		}		/**		 * Apply a set of acceleration forces and gravity to the ball collection.		 */		private function applyForces(ax : Number, ay : Number, gravity : Number) : void {			for (var i : int = 0; i < ballCollection.length ; i++) {				ballCollection[i].ax = ax;				ballCollection[i].ay = ay;				ballCollection[i].gravityY = gravity;					invalidate( );			}					}		/**		 * Apply a set of acceleration forces and gravity to the ball collection.		 */		private function applyAlpha(a : Number) : void {			for (var i : int = 0; i < ballCollection.length ; i++) {				//ballCollection[i].alpha = a;				Tweener.addTween( ballCollection[i], { base:METER_TWEEN, alpha:a, delay:(0.01 * i) } );			}					}		/**		 * Quickly reset the forces on the all ball collection.		 */		private function resetForces() : void {			applyForces( 0, 0, 10 ); // this falls hard with full gravity of 20.		}		/**		 * Increase the min threshold for esense activity.		 */		private function incrementThreshold() : void {			esenseThreshold = ((esenseThreshold + THRESHOLD_INCREMENT) <= 100) ? (esenseThreshold + THRESHOLD_INCREMENT) : THRESHOLD_INCREMENT;			updateHeader( );		}		/**		 * Update the textfield with the latest data.		 */		private function updateHeader() : void {			var delimeter : String = " | ";			var str : String = fontColor( '<a href="event:' + TEXTLINK_FULLSCREEN_EVENT + '">' + CAPTION + '</a>', CAPTION_TITLE_COLOR );			str += delimeter + fontColor( ATTENTION_LABEL, ATTENTION_COLOR ) + " [" + attentionMeterLevelName.toUpperCase( ) + "]: <a href='event:" + TEXTLINK_THRESHOLD_EVENT + "'>" + fontColor( attention, ATTENTION_COLOR ) + "/" + fontColor( esenseThreshold, CAPTION_SUB_COLOR ) + "</a>";			str += delimeter + fontColor( MEDITATION_LABEL, MEDITATION_COLOR ) + " [" + meditationMeterLevelName.toUpperCase( ) + "]: <a href='event:" + TEXTLINK_THRESHOLD_EVENT + "'>" + fontColor( meditation, MEDITATION_COLOR ) + "/" + fontColor( esenseThreshold, CAPTION_SUB_COLOR ) + "</a>";			if(powerData) {				str += delimeter;				str += DELTA_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.delta, FLOAT_PRECISION ), DELTA_COLOR ) + delimeter;				str += THETA_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.theta, FLOAT_PRECISION ), THETA_COLOR ) + delimeter;				str += ALPHA_LOW_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.alpha.low, FLOAT_PRECISION ), ALPHA_LOW_COLOR ) + delimeter;				str += ALPHA_HIGH_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.alpha.high, FLOAT_PRECISION ), ALPHA_HIGH_COLOR ) + delimeter;				str += BETA_LOW_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.beta.low, FLOAT_PRECISION ), BETA_LOW_COLOR ) + delimeter;				str += BETA_HIGH_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.beta.high, FLOAT_PRECISION ), BETA_HIGH_COLOR ) + delimeter;				str += GAMMA_LOW_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.gamma.low, FLOAT_PRECISION ), GAMMA_LOW_COLOR ) + delimeter;				str += GAMMA_HIGH_LABEL + ": " + fontColor( MathBase.sanitizeFloat( powerData.gamma.high, FLOAT_PRECISION ), GAMMA_HIGH_COLOR );													}			tf.htmlText = str;			tf.setTextFormat( fmt );		}		/**		 * Resolves an eSense level to a specific description string.		 */		private function resolveMeterLevelName(eSenseLevel : int) : String {			if(eSenseLevel == METER.none.min) {				return METER.none.name;			}			if(eSenseLevel >= METER.lowest.min && eSenseLevel <= METER.lowest.max ) {				return METER.lowest.name;			}			if(eSenseLevel >= METER.low.min && eSenseLevel <= METER.low.max ) {				return METER.low.name;			}			if(eSenseLevel >= METER.medium.min && eSenseLevel <= METER.medium.max ) {				return METER.medium.name;			}									if(eSenseLevel >= METER.high.min && eSenseLevel <= METER.high.max ) {				return METER.high.name;			}											if(eSenseLevel >= METER.highest.min && eSenseLevel <= METER.highest.max ) {				return METER.highest.name;			}								return '???';		}		/**		 * Wrap a string in a font color tag.		 */		private function fontColor(str : *, color : uint) : String {			return "<font color='" + ColorUtil.toHTML( color ) + "'>" + str + "</font>";		}		/**		 * Wrapper for htmlText link action.		 */		public function captionLinkClickHandler(e : TextEvent) : void {			switch (e.text) {				case TEXTLINK_FULLSCREEN_EVENT:					StageDisplay.$.toggleFullscreen( );					break;				case TEXTLINK_THRESHOLD_EVENT:					incrementThreshold( );					break;			}		}	}}